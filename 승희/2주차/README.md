### 영속성 컨텍스트란

- 엔티티를 영구 저장하는 환경이라는 뜻

```java
entityManager.persist(entity);
```

엔티티를 저장하는 것 x / 영속성 컨텍스트에 저장하는 것 o

- 바로 DB 에 저장되는 것은 아님

1. 비영속
- 그냥 객체를 생성한 상태 
2. 영속
- persist 해서 영속성 상태로 넣은 것
3. 준영속
- detach 해서 영속성 컨텍스트에서 삭제
4. 영구 삭제

### 영속성 컨텍스트의 이점

1. 1차 캐시
    - 바로 DB 를 뒤지지 않고 캐시를 먼저 조회
    - 사실상 큰 이점은 없다.
        - 하나의 트랜잭션 안에서의 캐싱이기 때문에
    - 조회 시에 조회 쿼리가 나가지 않음
        - 1차 캐시 내부에서 조회가 가능해서 굳이 DB까지 접근 x
2. 영속 엔티티의 동일성 보장
    - == 비교가 가능하다
    - 컬렉션에서 꺼내서 비교하는 것처럼
3. 쓰기 지연
    - 커밋하기 전까지 쿼리를 보내지 않고 쌓아둔다
4. 변경 감지
    - 변경을 하면 persist 를 하지 않는다
    - 그냥 값을 변경만 ex) setName 만 해도 업데이트 쿼리가 나간다
    - 최초로 들어온 상태를 스냅샷으로 떠두고, 커밋되는 시점에 일일이 비교하여 변경된 부분을 확인하고 변경되었으면 업데이트 쿼리 나감

### flush

- 영속성 컨텍스트의 변경내용을 DB 에 반영
- 쓰기 지연 SQL 저장소의 쿼리를 DB 에 전송
- 플러시 방법
    1. em.flush()
    2. 트랜잭션 커밋
    3. JPQL 쿼리 실행



### 준영속 상태
- 영속성 컨텍스트에서 분리되고, 영속성 컨텍스트가 제공하는 기능을 사용하지 못하는 것
- em.detach(entity)
- em.clear() 모두 삭제
- em.close() 영속성 컨텍스트를 종료
- 이미 DB에 한번 저장됐거나 식별자가 존재하는 엔티티 → 따라서 이미 한번 저장된 적이 있는 (다른 영속성 컨텍스트에서) 엔티티는 변경 감지가 일어나지 않는다.
    1. 변경감지 기능 사용 → 해당 객체를 다시 DB에서 조회해온다 (em.find())
    2. 병합 사용 → em.merge() 영속상태로 변경하기
  
  [[JPA] 준영속 상태와 변경 감지](https://velog.io/@wogud7587/JPA-준영속-상태와-변경-감지)