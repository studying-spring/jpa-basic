# About JPA

- ORM: Object Relational Mapping{객체 관계 매핑}
- 객체는 객체대로 설계, 관계형 데이터베이스와 매핑을 해준다.
- JPA는 JDBC API와 애플리케이션 사이에서 존재
## JPA 부분이 중요한게 패러다임 불일치를 해결해준다는 것
- 상속된 것도 알아서 매핑해줘서 CRUD해준다.
- 연관 관계와 객체 그래프 탐색(멤버 꺼내고 멤버에서 team꺼내고)
- 신뢰할 수 있는 엔티티, 계층
- 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장
## 성능 최적화 기능
- 1차 캐시와 동일성 보장(4번과 동일): jpa.find를 하면, jpa가 셀렉을 하고, 그 메모리에서 찾게됨. 그래서 같음(트랜잭션 안에서)
- 트랜잭션을 지원하는 쓰기 지연: 트랜잭션이 시작하고 커리를 모아두었다가 한번에 commit을 한다. (버퍼writing)
- 지연 로딩과 즉시 로딩: 멤버를 조회할 때 팀을 조회 많이하는가?(상화마다 이걸 고려, 성능 굿)
- 지연 로딩: 객체가 직접 사용될 때(팀을 자주 불러오지 않을 때. 마지막에 팀을 셀렉)
- 즉시 로딩: 멤버랑 팀이랑 같이 조회를 하네? -> 멤버를 조회하면 팀도 즉시 셀렉
- 근데 보통 지연 로딩으로 해두고 즉시로딩으로 부분부분 바꿔준다.
JPA 표준 인터페이스에 하이버네이트를 쓴다.
트랜잭션이 끝나면 알아서 이름을 바꾸면 저장이 된다.(오..)

# 영속성 컨텍스트

- 비영속: jpa랑 상관 없는 상태
- 영속: 멤버 객체를 생성하고, 엔티티 메니저를 불러와서 persist에 멤버를 담음 → 멤버는 영속 상태가 되고 영속 컨텍스트에 담김, 영속 컨텍스트가 된다해도 쿼리가 날라가지 않음. commit을 해야 날라감
- detach는 영속 컨텍스트에서 삭제, remove는 데베에서 영구 삭제
- 1차 캐시에서 조회.  → 한 트랜잭션 안에서만 있음 1차 캐시는
- 없으면 데베 조회, 조회하고 1차캐시에 저장을 함
- == 비교하면 같은 걸로 나옴. 캐시에서 불러왔기 때문
- 쓰기 지연 SQL 저장소가 있음. commit을 하면 flush 되면서 실제 SQL 작동
- 버퍼링 기능도 있다. 몇 개 모았다가 보내는
- 엔티티 수정 → 더티 감지도 가능, member를 불러내서 값을 변경할 때, persist를 적을 필요는 없다. 스냅샷이 있기 때문. 영속성 컨텍스트 에불러온 1차 캐시 시점을 저장. flush()가 실행될 때, 현재 상태랑 스냅샷이랑 비교를하고, 바뀌어있으면 업데이트 쿼리를 SQL저장소에 넣어둠
- 그러니깐 값을 바꾸면 트랜잭션에 커밋되는 시점에 별다른 코드가 없어도 업데이트가 된다.

### 플러시

- 영속성 컨텍스트의 변경내용을 데베에 반영하는 것
- 변경 감지, 수정된 엔티티 지연 SQL등록하고 SQL 저장소 쿼리를 데베에 전송
- 플러시를 해도 1차캐시를 가지고 있다.

### 준영속상태

- 영속성 컨텐트에서 분리
- em.detach()